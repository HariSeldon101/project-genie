/**
 * SSE Event Factory
 *
 * ⚠️ DEPRECATED as of 2025-01-13 ⚠️
 *
 * This file is deprecated and will be removed in a future version.
 * Please migrate to the unified event system:
 *
 * OLD (this file):
 * import { SSEEventFactory } from '@/lib/company-intelligence/utils/sse-event-factory'
 *
 * NEW (unified system):
 * import { EventFactory } from '@/lib/realtime-events'
 *
 * The new EventFactory has the same methods with improved features:
 * - Type safety across client/server boundary
 * - Automatic reconnection support
 * - Memory leak prevention
 * - Unified with notification events
 *
 * Migration is currently handled via adapters, but direct usage is recommended.
 * See /lib/realtime-events/README.md for migration guide.
 *
 * @deprecated Use EventFactory from @/lib/realtime-events instead
 */

import { nanoid } from 'nanoid'
import { permanentLogger } from '@/lib/utils/permanent-logger'

export enum EventType {
  PROGRESS = 'progress',
  DATA = 'data',
  ERROR = 'error',
  COMPLETE = 'complete',
  STATUS = 'status',
  WARNING = 'warning'
}

export enum EventSource {
  SCRAPER = 'scraper',
  EXTRACTOR = 'extractor',
  ENRICHER = 'enricher',
  ANALYZER = 'analyzer',
  API = 'api',
  CLIENT = 'client',
  SYSTEM = 'system'
}

export interface ProgressInfo {
  current: number
  total: number
  percentage: number
  message?: string
  phase?: string
}

export interface EventMetadata {
  source: EventSource | string
  phase?: string
  progress?: ProgressInfo
  [key: string]: any
}

export interface SSEEvent<T = any> {
  id: string
  type: EventType
  timestamp: number
  correlationId: string
  sequence: number
  data: T
  metadata: EventMetadata
}

export class SSEEventFactory {
  private static sequenceCounter = 0
  private static correlationMap = new Map<string, string>()

  /**
   * Reset sequence counter (useful for new streams)
   */
  static resetSequence(): void {
    this.sequenceCounter = 0
  }

  /**
   * Get or create correlation ID for a session
   */
  static getCorrelationId(sessionId?: string): string {
    if (sessionId && this.correlationMap.has(sessionId)) {
      return this.correlationMap.get(sessionId)!
    }
    const correlationId = nanoid()
    if (sessionId) {
      this.correlationMap.set(sessionId, correlationId)
    }
    return correlationId
  }

  /**
   * Create a progress event
   */
  static progress(
    current: number,
    total: number,
    message?: string,
    metadata?: Partial<EventMetadata>
  ): SSEEvent<ProgressInfo> {
    const percentage = total > 0 ? Math.round((current / total) * 100) : 0
    const progress: ProgressInfo = {
      current,
      total,
      percentage,
      message,
      phase: metadata?.phase
    }

    const event: SSEEvent<ProgressInfo> = {
      id: nanoid(),
      type: EventType.PROGRESS,
      timestamp: Date.now(),
      correlationId: this.getCorrelationId(metadata?.correlationId as string),
      sequence: ++this.sequenceCounter,
      data: progress,
      metadata: {
        source: metadata?.source || EventSource.SYSTEM,
        phase: metadata?.phase,
        progress,
        ...metadata
      }
    }

    permanentLogger.info('Progress event created', { category: 'SSE_EVENT_FACTORY', ...{
      id: event.id,
      sequence: event.sequence,
      percentage,
      message: message?.substring(0, 50 })
    })

    return event
  }

  /**
   * Create a data event
   */
  static data<T>(
    data: T,
    metadata?: Partial<EventMetadata>
  ): SSEEvent<T> {
    const event: SSEEvent<T> = {
      id: nanoid(),
      type: EventType.DATA,
      timestamp: Date.now(),
      correlationId: this.getCorrelationId(metadata?.correlationId as string),
      sequence: ++this.sequenceCounter,
      data,
      metadata: {
        source: metadata?.source || EventSource.SYSTEM,
        ...metadata
      }
    }

    permanentLogger.info('Data event created', { category: 'SSE_EVENT_FACTORY', ...{
      id: event.id,
      sequence: event.sequence,
      correlationId: event.correlationId,
      dataType: typeof data,
      dataSize: JSON.stringify(data }).length
    })

    return event
  }

  /**
   * Create an error event
   */
  static error(
    error: Error | string,
    metadata?: Partial<EventMetadata>
  ): SSEEvent<{ message: string; stack?: string; code?: string }> {
    const errorData = {
      message: error instanceof Error ? error.message : error,
      stack: error instanceof Error ? error.stack : undefined,
      code: metadata?.code as string
    }

    const event: SSEEvent<typeof errorData> = {
      id: nanoid(),
      type: EventType.ERROR,
      timestamp: Date.now(),
      correlationId: this.getCorrelationId(metadata?.correlationId as string),
      sequence: ++this.sequenceCounter,
      data: errorData,
      metadata: {
        source: metadata?.source || EventSource.SYSTEM,
        ...metadata
      }
    }

    permanentLogger.captureError('SSE_EVENT_FACTORY', new Error('Error event created'), {
      id: event.id,
      sequence: event.sequence,
      message: errorData.message,
      stack: errorData.stack,
      correlationId: event.correlationId
    })

    return event
  }

  /**
   * Create a complete event
   */
  static complete<T>(
    result?: T,
    metadata?: Partial<EventMetadata>
  ): SSEEvent<T | { message: string }> {
    const data = result || { message: 'Process completed successfully' }

    const event: SSEEvent<typeof data> = {
      id: nanoid(),
      type: EventType.COMPLETE,
      timestamp: Date.now(),
      correlationId: this.getCorrelationId(metadata?.correlationId as string),
      sequence: ++this.sequenceCounter,
      data,
      metadata: {
        source: metadata?.source || EventSource.SYSTEM,
        ...metadata
      }
    }

    permanentLogger.info('Complete event created', { category: 'SSE_EVENT_FACTORY', id: event.id,
      sequence: event.sequence,
      correlationId: event.correlationId,
      hasResult: !!result })

    return event
  }

  /**
   * Create a status event
   */
  static status(
    status: string,
    details?: any,
    metadata?: Partial<EventMetadata>
  ): SSEEvent<{ status: string; details?: any }> {
    const event: SSEEvent<{ status: string; details?: any }> = {
      id: nanoid(),
      type: EventType.STATUS,
      timestamp: Date.now(),
      correlationId: this.getCorrelationId(metadata?.correlationId as string),
      sequence: ++this.sequenceCounter,
      data: { status, details },
      metadata: {
        source: metadata?.source || EventSource.SYSTEM,
        ...metadata
      }
    }

    permanentLogger.info('Status event created', { category: 'SSE_EVENT_FACTORY', id: event.id,
      sequence: event.sequence,
      status,
      correlationId: event.correlationId })

    return event
  }

  /**
   * Create a warning event
   */
  static warning(
    message: string,
    details?: any,
    metadata?: Partial<EventMetadata>
  ): SSEEvent<{ message: string; details?: any }> {
    const event: SSEEvent<{ message: string; details?: any }> = {
      id: nanoid(),
      type: EventType.WARNING,
      timestamp: Date.now(),
      correlationId: this.getCorrelationId(metadata?.correlationId as string),
      sequence: ++this.sequenceCounter,
      data: { message, details },
      metadata: {
        source: metadata?.source || EventSource.SYSTEM,
        ...metadata
      }
    }

    permanentLogger.warn('SSE_EVENT_FACTORY', 'Warning event created', {
      id: event.id,
      sequence: event.sequence,
      message,
      correlationId: event.correlationId
    })

    return event
  }

  /**
   * Format event for SSE transmission
   */
  static formatForSSE(event: SSEEvent): string {
    return `data: ${JSON.stringify(event)}\n\n`
  }

  /**
   * Create from legacy format (for migration)
   */
  static fromLegacy(legacyData: any, type?: EventType): SSEEvent {
    // Handle nested payload structures
    const actualData = legacyData.payload?.details || legacyData.payload || legacyData
    
    return {
      id: legacyData.id || nanoid(),
      type: legacyData.type || type || EventType.DATA,
      timestamp: legacyData.timestamp || Date.now(),
      correlationId: legacyData.correlationId || this.getCorrelationId(),
      sequence: legacyData.sequence || ++this.sequenceCounter,
      data: actualData,
      metadata: {
        source: legacyData.source || EventSource.SYSTEM,
        phase: legacyData.phase,
        migrated: true,
        originalFormat: 'legacy'
      }
    }
  }
}