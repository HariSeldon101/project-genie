/**
 * Page Intelligence Analyzer
 * Main orchestrator for page classification and intelligence extraction
 */

import { permanentLogger } from '@/lib/utils/permanent-logger'
import { StructuredDataExtractor } from './structured-data-extractor'
import { ContentPatternMatcher } from './content-pattern-matcher'
import { 
  PageClassificationResult, 
  PageIntelligenceConfig, 
  IntelligenceSession, 
  PageIntelligenceError,
  IntelligenceSummary,
  PageType
} from './types'

export class PageIntelligenceAnalyzer {
  private domain: string
  private config: PageIntelligenceConfig
  private structuredDataExtractor: StructuredDataExtractor
  private contentPatternMatcher: ContentPatternMatcher
  private session?: IntelligenceSession
  
  // Default configuration
  private static readonly DEFAULT_CONFIG: PageIntelligenceConfig = {
    enableUrlPatterns: true,
    urlPatternWeight: 0.7,
    enableContentAnalysis: true,
    contentAnalysisWeight: 0.3,
    enableStructuredData: true,
    enableMetaExtraction: true,
    minimumConfidence: 0.3,
    highConfidenceThreshold: 0.8,
    maxProcessingTime: 10000, // 10 seconds
    enableDetailedLogging: true
  }

  constructor(domain: string, config?: Partial<PageIntelligenceConfig>) {
    this.domain = domain
    this.config = { ...PageIntelligenceAnalyzer.DEFAULT_CONFIG, ...config }
    
    // Initialize component analyzers
    this.structuredDataExtractor = new StructuredDataExtractor(domain)
    this.contentPatternMatcher = new ContentPatternMatcher(domain)
    
    permanentLogger.info('PageIntelligenceAnalyzer initialized', { category: 'INTELLIGENCE', domain,
      config: this.config })
  }

  /**
   * Start a new intelligence session
   */
  public startSession(sessionId?: string): IntelligenceSession {
    const session: IntelligenceSession = {
      sessionId: sessionId || `intel_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
      domain: this.domain,
      startedAt: new Date(),
      config: this.config,
      pagesAnalyzed: 0,
      successfulClassifications: 0,
      failedClassifications: 0,
      totalProcessingTime: 0,
      averageProcessingTime: 0,
      pageTypeCounts: {} as Record<PageType, number>,
      averageConfidence: 0,
      highConfidencePages: 0,
      lowConfidencePages: 0
    }
    
    this.session = session
    
    permanentLogger.info('Intelligence session started', { category: 'INTELLIGENCE', sessionId: session.sessionId,
      domain: this.domain })
    
    return session
  }

  /**
   * Analyze a single page and classify its type
   */
  public async analyzePage(url: string, html?: string): Promise<PageClassificationResult> {
    const startTime = Date.now()
    
    try {
      permanentLogger.info('Starting page analysis', { category: 'INTELLIGENCE', url, 
        domain: this.domain,
        hasHtml: !!html })

      // Fetch HTML if not provided
      if (!html) {
        html = await this.fetchPageHtml(url)
      }

      // Initialize result object
      const result: PageClassificationResult = {
        url,
        pageType: 'unknown',
        confidence: 0,
        urlPatterns: [],
        contentSignals: [],
        metaData: {},
        structuredData: {},
        analysisTimestamp: new Date(),
        processingTimeMs: 0,
        errors: [],
        warnings: []
      }

      // 1. Analyze URL patterns
      if (this.config.enableUrlPatterns) {
        try {
          result.urlPatterns = this.contentPatternMatcher.analyzeUrlPatterns(url)
          permanentLogger.info('URL pattern analysis completed', { category: 'INTELLIGENCE', url,
            patternsFound: result.urlPatterns.length })
        } catch (error) {
          const errorMsg = `URL pattern analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`
          result.warnings?.push(errorMsg)
          permanentLogger.warn('INTELLIGENCE', errorMsg, { url })
        }
      }

      // 2. Analyze content patterns
      if (this.config.enableContentAnalysis && html) {
        try {
          const contentSignals = this.contentPatternMatcher.analyzeContentSignals(html, url)
          const structuralSignals = this.contentPatternMatcher.analyzePageStructure(html, url)
          result.contentSignals = [...contentSignals, ...structuralSignals]
          
          permanentLogger.info('Content analysis completed', { category: 'INTELLIGENCE', url,
            contentSignals: contentSignals.length,
            structuralSignals: structuralSignals.length })
        } catch (error) {
          const errorMsg = `Content analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`
          result.warnings?.push(errorMsg)
          permanentLogger.warn('INTELLIGENCE', errorMsg, { url })
        }
      }

      // 3. Extract structured data
      if (this.config.enableStructuredData && html) {
        try {
          result.structuredData = this.structuredDataExtractor.extractStructuredData(html, url)
          permanentLogger.info('Structured data extraction completed', { category: 'INTELLIGENCE', url,
            jsonLdCount: result.structuredData.jsonLd?.length || 0,
            hasOrganization: !!result.structuredData.organization,
            hasProducts: !!result.structuredData.products?.length,
            hasPeople: !!result.structuredData.people?.length })
        } catch (error) {
          const errorMsg = `Structured data extraction failed: ${error instanceof Error ? error.message : 'Unknown error'}`
          result.warnings?.push(errorMsg)
          permanentLogger.warn('INTELLIGENCE', errorMsg, { url })
        }
      }

      // 4. Extract meta data
      if (this.config.enableMetaExtraction && html) {
        try {
          result.metaData = this.structuredDataExtractor.extractMetaData(html, url)
          permanentLogger.info('Meta data extraction completed', { category: 'INTELLIGENCE', ...{
            url,
            fieldsExtracted: Object.keys(result.metaData }).filter(k => result.metaData[k as keyof typeof result.metaData] !== undefined).length
          })
        } catch (error) {
          const errorMsg = `Meta data extraction failed: ${error instanceof Error ? error.message : 'Unknown error'}`
          result.warnings?.push(errorMsg)
          permanentLogger.warn('INTELLIGENCE', errorMsg, { url })
        }
      }

      // 5. Determine primary page type and confidence
      const classification = this.contentPatternMatcher.determinePrimaryPageType(
        result.urlPatterns,
        result.contentSignals
      )
      
      result.pageType = classification.pageType
      result.confidence = classification.confidence

      // 6. Apply confidence thresholds
      if (result.confidence < this.config.minimumConfidence) {
        result.pageType = 'unknown'
        result.warnings?.push(`Confidence ${result.confidence.toFixed(2)} below minimum threshold ${this.config.minimumConfidence}`)
      }

      // 7. Calculate processing time
      result.processingTimeMs = Date.now() - startTime

      // 8. Update session statistics
      if (this.session) {
        this.updateSessionStats(result)
      }

      permanentLogger.info('Page analysis completed', { category: 'INTELLIGENCE', url,
        pageType: result.pageType,
        confidence: result.confidence,
        processingTime: result.processingTimeMs,
        warnings: result.warnings?.length || 0,
        errors: result.errors?.length || 0 })

      return result

    } catch (error) {
      const processingTime = Date.now() - startTime
      const errorResult: PageClassificationResult = {
        url,
        pageType: 'unknown',
        confidence: 0,
        urlPatterns: [],
        contentSignals: [],
        metaData: {},
        structuredData: {},
        analysisTimestamp: new Date(),
        processingTimeMs: processingTime,
        errors: [error instanceof Error ? error.message : 'Unknown analysis error']
      }

      // Update session with failed classification
      if (this.session) {
        this.session.failedClassifications++
        this.session.pagesAnalyzed++
      }

      permanentLogger.captureError('INTELLIGENCE', error, {
        message: 'Page analysis failed',
        url,
        domain: this.domain,
        processingTime,
        errorMessage: error instanceof Error ? error.message : 'Unknown error'
      })

      return errorResult
    }
  }

  /**
   * Analyze multiple pages in batch
   */
  public async analyzePages(urls: string[]): Promise<PageClassificationResult[]> {
    const results: PageClassificationResult[] = []
    
    permanentLogger.info('Starting batch page analysis', { category: 'INTELLIGENCE', urlCount: urls.length,
      domain: this.domain })

    // Process pages with limited concurrency to avoid overwhelming servers
    const BATCH_SIZE = 3
    
    for (let i = 0; i < urls.length; i += BATCH_SIZE) {
      const batch = urls.slice(i, i + BATCH_SIZE)
      
      const batchPromises = batch.map(url => 
        this.analyzePage(url).catch(error => {
          permanentLogger.captureError('INTELLIGENCE', new Error('Batch analysis error'), { url, error })
          return {
            url,
            pageType: 'unknown' as PageType,
            confidence: 0,
            urlPatterns: [],
            contentSignals: [],
            metaData: {},
            structuredData: {},
            analysisTimestamp: new Date(),
            processingTimeMs: 0,
            errors: [error instanceof Error ? error.message : 'Batch processing error']
          }
        })
      )
      
      const batchResults = await Promise.all(batchPromises)
      results.push(...batchResults)
      
      // Small delay between batches to be respectful
      if (i + BATCH_SIZE < urls.length) {
        await new Promise(resolve => setTimeout(resolve, 500))
      }
    }

    permanentLogger.info('Batch analysis completed', { category: 'INTELLIGENCE', ...{
      urlCount: urls.length,
      successfulAnalyses: results.filter(r => r.pageType !== 'unknown' }).length,
      domain: this.domain
    })

    return results
  }

  /**
   * Generate intelligence summary for the domain
   */
  public generateIntelligenceSummary(results: PageClassificationResult[]): IntelligenceSummary {
    const summary: IntelligenceSummary = {
      domain: this.domain,
      totalPages: results.length,
      pageTypeDistribution: {},
      hasEcommerce: false,
      hasBlog: false,
      hasTeamPage: false,
      hasProductPages: false,
      overallConfidence: 0,
      structuredDataCoverage: 0,
      metaDataCompleteness: 0,
      detectedTechnologies: [],
      seoOptimization: 'low',
      contentStrategy: {
        productFocus: false,
        serviceOriented: false,
        b2bFocus: false,
        b2cFocus: false
      }
    }

    if (results.length === 0) return summary

    // Calculate page type distribution
    const pageTypeCounts: Record<string, number> = {}
    let totalConfidence = 0
    let pagesWithStructuredData = 0
    let pagesWithCompleteMetaData = 0

    for (const result of results) {
      // Count page types
      pageTypeCounts[result.pageType] = (pageTypeCounts[result.pageType] || 0) + 1
      totalConfidence += result.confidence

      // Check for structured data
      if (result.structuredData && Object.keys(result.structuredData).length > 0) {
        pagesWithStructuredData++
      }

      // Check for complete meta data
      const metaFields = Object.keys(result.metaData).filter(k => result.metaData[k as keyof typeof result.metaData] !== undefined)
      if (metaFields.length > 5) { // Consider 5+ fields as "complete"
        pagesWithCompleteMetaData++
      }
    }

    // Build page type distribution
    for (const [pageType, count] of Object.entries(pageTypeCounts)) {
      const typeResults = results.filter(r => r.pageType === pageType)
      const averageConfidence = typeResults.reduce((sum, r) => sum + r.confidence, 0) / typeResults.length

      summary.pageTypeDistribution[pageType as PageType] = {
        count,
        percentage: (count / results.length) * 100,
        averageConfidence
      }
    }

    // Set boolean flags
    summary.hasEcommerce = !!(pageTypeCounts['product'] || pageTypeCounts['product_listing'])
    summary.hasBlog = !!(pageTypeCounts['blog'] || pageTypeCounts['blog_post'])
    summary.hasTeamPage = !!pageTypeCounts['team']
    summary.hasProductPages = !!pageTypeCounts['product']

    // Calculate metrics
    summary.overallConfidence = totalConfidence / results.length
    summary.structuredDataCoverage = (pagesWithStructuredData / results.length) * 100
    summary.metaDataCompleteness = (pagesWithCompleteMetaData / results.length) * 100

    // Determine SEO optimization level
    if (summary.metaDataCompleteness > 70 && summary.structuredDataCoverage > 30) {
      summary.seoOptimization = 'high'
    } else if (summary.metaDataCompleteness > 40 || summary.structuredDataCoverage > 15) {
      summary.seoOptimization = 'medium'
    }

    // Analyze content strategy
    const blogRatio = (pageTypeCounts['blog'] || 0) + (pageTypeCounts['blog_post'] || 0)
    const productRatio = (pageTypeCounts['product'] || 0) + (pageTypeCounts['product_listing'] || 0)
    const serviceRatio = pageTypeCounts['service'] || 0

    summary.contentStrategy.productFocus = productRatio > blogRatio
    summary.contentStrategy.serviceOriented = serviceRatio > 0
    summary.contentStrategy.b2bFocus = !!(pageTypeCounts['case_study'] || pageTypeCounts['testimonial'])
    summary.contentStrategy.b2cFocus = !!pageTypeCounts['product']

    if (blogRatio > 10) {
      summary.contentStrategy.blogFrequency = 'high'
    } else if (blogRatio > 3) {
      summary.contentStrategy.blogFrequency = 'medium'
    } else if (blogRatio > 0) {
      summary.contentStrategy.blogFrequency = 'low'
    }

    permanentLogger.info('Intelligence summary generated', { category: 'INTELLIGENCE', ...{
      domain: this.domain,
      totalPages: summary.totalPages,
      overallConfidence: summary.overallConfidence,
      seoOptimization: summary.seoOptimization,
      pageTypes: Object.keys(summary.pageTypeDistribution }).length
    })

    return summary
  }

  /**
   * Fetch HTML content from a URL
   */
  private async fetchPageHtml(url: string): Promise<string> {
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), this.config.maxProcessingTime)

    try {
      const response = await fetch(url, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; CompanyIntelligenceBot/1.0; +https://projectgenie.ai)',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.5',
          'Accept-Encoding': 'gzip, deflate',
          'Cache-Control': 'no-cache'
        },
        signal: controller.signal
      })

      clearTimeout(timeoutId)

      if (!response.ok) {
        throw new PageIntelligenceError(`HTTP ${response.status}: ${response.statusText}`, 'FETCH_FAILED', url)
      }

      const html = await response.text()
      
      permanentLogger.info('Page HTML fetched successfully', { category: 'INTELLIGENCE', ...{
        url,
        htmlLength: html.length,
        contentType: response.headers.get('content-type' })
      })

      return html

    } catch (error) {
      clearTimeout(timeoutId)
      
      if (error instanceof Error && error.name === 'AbortError') {
        throw new PageIntelligenceError('Request timeout', 'TIMEOUT', url)
      }
      
      throw new PageIntelligenceError(
        error instanceof Error ? error.message : 'Unknown fetch error',
        'FETCH_FAILED',
        url
      )
    }
  }

  /**
   * Update session statistics
   */
  private updateSessionStats(result: PageClassificationResult): void {
    if (!this.session) return

    this.session.pagesAnalyzed++
    this.session.totalProcessingTime += result.processingTimeMs

    if (result.pageType !== 'unknown') {
      this.session.successfulClassifications++
      
      // Update page type counts
      this.session.pageTypeCounts[result.pageType] = (this.session.pageTypeCounts[result.pageType] || 0) + 1
    } else {
      this.session.failedClassifications++
    }

    // Update confidence statistics
    if (result.confidence >= this.config.highConfidenceThreshold) {
      this.session.highConfidencePages++
    } else if (result.confidence < this.config.minimumConfidence) {
      this.session.lowConfidencePages++
    }

    // Calculate running averages
    this.session.averageProcessingTime = this.session.totalProcessingTime / this.session.pagesAnalyzed
    
    const successfulResults = this.session.successfulClassifications
    if (successfulResults > 0) {
      // This is a simplified average - in a full implementation you'd track all confidence scores
      this.session.averageConfidence = (this.session.averageConfidence * (successfulResults - 1) + result.confidence) / successfulResults
    }
  }

  /**
   * Get current session statistics
   */
  public getSession(): IntelligenceSession | undefined {
    return this.session
  }
}

// Custom error class for page intelligence errors
class PageIntelligenceError extends Error implements PageIntelligenceError {
  public code: 'FETCH_FAILED' | 'PARSE_FAILED' | 'TIMEOUT' | 'INVALID_URL' | 'UNKNOWN'
  public url?: string
  public details?: any

  constructor(message: string, code: PageIntelligenceError['code'], url?: string, details?: any) {
    super(message)
    this.name = 'PageIntelligenceError'
    this.code = code
    this.url = url
    this.details = details
  }
}