/**
 * Permanent Logger Adapter
 * Integrates permanent logger with the event bus for unified logging
 */

import { permanentLogger } from '@/lib/utils/permanent-logger'
import { eventBus } from '../event-bus'
import {
  EventAdapter,
  EventHandler,
  EventSource,
  EventPriority,
  Event
} from '../types'

export class LoggerAdapter implements EventAdapter {
  name = 'Logger Adapter'
  source = EventSource.SYSTEM
  private handler: EventHandler | null = null
  private logLevels: Set<string> = new Set(['ERROR', 'CRITICAL', 'WARNING'])
  private subscriptionId: string | null = null
  private isProcessingEvent = false // Add flag to prevent circular dependency

  constructor(logLevels?: string[]) {
    if (logLevels) {
      this.logLevels = new Set(logLevels)
    }
  }

  async connect(): Promise<void> {
    permanentLogger.info('Connecting logger adapter to event bus', { category: 'LOGGER_ADAPTER' })
    
    // Subscribe to all events and log them
    this.subscriptionId = eventBus.subscribe((event: Event) => {
      this.logEvent(event)
    })

    // Also intercept permanent logger calls to create notifications for errors
    this.interceptLoggerCalls()
    
    permanentLogger.info('Logger adapter connected', { category: 'LOGGER_ADAPTER' })
  }

  private logEvent(event: Event): void {
    // Skip if we're already processing to prevent circular calls
    if (this.isProcessingEvent) return
    
    this.isProcessingEvent = true
    try {
      // Log all events to permanent logger with appropriate metadata
      const logData = {
        eventId: event.id,
        type: event.type,
        source: event.source,
        priority: this.getPriorityName(event.priority),
        correlationId: event.correlationId,
        payload: event.payload,
        metadata: event.metadata
      }

      // Determine log level based on event
      if (event.type === 'notification' && 'notificationType' in event.payload) {
        const notifType = (event.payload as any).notificationType
        if (notifType === 'error') {
          permanentLogger.captureError('EVENT_BUS', logData, { message: 'Error notification' })
        } else if (notifType === 'warning') {
          permanentLogger.warn('EVENT_BUS', 'Warning notification', logData)
        } else {
          permanentLogger.info('Notification', { category: 'EVENT_BUS', ...logData })
        }
      } else if (event.type === 'phase') {
        const status = (event.payload as any).status
        if (status === 'failed') {
          permanentLogger.captureError('EVENT_BUS', logData, { message: 'Phase failed' })
        } else {
          permanentLogger.info('Phase event', { category: 'EVENT_BUS', ...logData })
        }
      } else {
        permanentLogger.info('Event processed', { category: 'EVENT_BUS', ...logData })
      }
    } finally {
      this.isProcessingEvent = false
    }
  }

  private interceptLoggerCalls(): void {
    // Store original methods
    const originalError = permanentLogger.error.bind(permanentLogger)
    const originalWarn = permanentLogger.warn.bind(permanentLogger)
    const originalCritical = (permanentLogger as any).critical?.bind(permanentLogger)

    // Override error method to also emit notifications
    permanentLogger.error = (category: string, message: string, data?: any) => {
      originalError(category, message, data)
      
      // Skip event emission if we're already processing an event
      if (this.isProcessingEvent) return
      
      if (this.shouldCreateNotification('ERROR', category)) {
        eventBus.emit({
          id: `logger_error_${Date.now()}`,
          type: 'notification',
          source: EventSource.SYSTEM,
          priority: EventPriority.CRITICAL,
          timestamp: Date.now(),
          metadata: { category, data },
          payload: {
            message: `[${category}] ${message}`,
            notificationType: 'error',
            persistent: true
          }
        })
      }
    }

    // Override warn method
    permanentLogger.warn = (category: string, message: string, data?: any) => {
      originalWarn(category, message, data)
      
      if (this.shouldCreateNotification('WARNING', category)) {
        eventBus.emit({
          id: `logger_warn_${Date.now()}`,
          type: 'notification',
          source: EventSource.SYSTEM,
          priority: EventPriority.HIGH,
          timestamp: Date.now(),
          metadata: { category, data },
          payload: {
            message: `[${category}] ${message}`,
            notificationType: 'warning',
            persistent: true
          }
        })
      }
    }

    // Override critical method if it exists
    if (originalCritical) {
      (permanentLogger as any).critical = (category: string, message: string, data?: any) => {
        originalCritical(category, message, data)
        
        if (this.shouldCreateNotification('CRITICAL', category)) {
          eventBus.emit({
            id: `logger_critical_${Date.now()}`,
            type: 'notification',
            source: EventSource.SYSTEM,
            priority: EventPriority.CRITICAL,
            timestamp: Date.now(),
            metadata: { category, data },
            payload: {
              message: `[CRITICAL] [${category}] ${message}`,
              notificationType: 'error',
              persistent: true
            }
          })
        }
      }
    }
  }

  private shouldCreateNotification(level: string, category: string): boolean {
    // Check if this log level should create notifications
    if (!this.logLevels.has(level)) {
      return false
    }

    // Filter out some categories that shouldn't create notifications
    const excludedCategories = ['EVENT_BUS', 'NOTIFICATION_CONTEXT', 'LOGGER_ADAPTER']
    return !excludedCategories.includes(category)
  }

  private getPriorityName(priority: EventPriority): string {
    switch (priority) {
      case EventPriority.CRITICAL:
        return 'CRITICAL'
      case EventPriority.HIGH:
        return 'HIGH'
      case EventPriority.NORMAL:
        return 'NORMAL'
      case EventPriority.LOW:
        return 'LOW'
      default:
        return 'UNKNOWN'
    }
  }

  async disconnect(): Promise<void> {
    if (this.subscriptionId) {
      eventBus.unsubscribe(this.subscriptionId)
      this.subscriptionId = null
    }
    permanentLogger.info('Logger adapter disconnected', { category: 'LOGGER_ADAPTER' })
  }

  subscribe(handler: EventHandler): void {
    this.handler = handler
  }

  unsubscribe(): void {
    this.handler = null
  }
}

/**
 * Singleton instance of logger adapter
 */
let loggerAdapterInstance: LoggerAdapter | null = null

/**
 * Initialize the logger adapter (call once at app startup)
 */
export async function initializeLoggerAdapter(logLevels?: string[]): Promise<LoggerAdapter> {
  if (!loggerAdapterInstance) {
    loggerAdapterInstance = new LoggerAdapter(logLevels)
    await loggerAdapterInstance.connect()
  }
  return loggerAdapterInstance
}

/**
 * Get the logger adapter instance
 */
export function getLoggerAdapter(): LoggerAdapter | null {
  return loggerAdapterInstance
}