/**
 * Projects Repository - Handles all database operations for projects
 *
 * Technical PM Note: This centralizes ALL project database access.
 * No other file should directly query the projects table.
 * This makes testing easy (mock this one class) and ensures consistent error handling.
 */

import { BaseRepository } from './base-repository'
import { permanentLogger } from '@/lib/utils/permanent-logger'
import type { Database } from '@/lib/database.types'

type Project = Database['public']['Tables']['projects']['Row']
type ProjectInsert = Database['public']['Tables']['projects']['Insert']
type ProjectUpdate = Database['public']['Tables']['projects']['Update']

export class ProjectsRepository extends BaseRepository {
  private static instance: ProjectsRepository

  static getInstance(): ProjectsRepository {
    if (!this.instance) {
      this.instance = new ProjectsRepository()
    }
    return this.instance
  }

  /**
   * Get all projects for the current user
   * CRITICAL: No fallback data - throws error if fails
   */
  async getUserProjects(): Promise<Project[]> {
    const timer = permanentLogger.timing('repository.getUserProjects')

    return this.execute('getUserProjects', async (client) => {
      permanentLogger.breadcrumb('repository', 'Fetching user projects', {
        timestamp: Date.now()
      })

      const user = await this.getCurrentUser()

      const { data, error } = await client
        .from('projects')
        .select('*')
        .eq('owner_id', user.id)
        .order('created_at', { ascending: false })

      if (error) {
        // NO FALLBACK - throw the error
        permanentLogger.captureError('PROJECTS_REPO', error, {
          operation: 'getUserProjects',
          userId: user.id
        })
        throw error
      }

      const duration = timer.stop()
      permanentLogger.breadcrumb('repository', 'Projects fetched', {
        count: data?.length || 0,
        duration
      })

      // Never return null or fallback - throw if no data
      if (!data) {
        throw new Error('Failed to fetch projects - no data returned')
      }

      return data
    })
  }

  /**
   * Get single project by ID with ownership validation
   * Technical PM: Ensures users can only access their own projects
   */
  async getProject(projectId: string): Promise<Project> {
    const timer = permanentLogger.timing('repository.getProject')

    return this.execute('getProject', async (client) => {
      permanentLogger.breadcrumb('repository', 'Fetching single project', {
        projectId,
        timestamp: Date.now()
      })

      const user = await this.getCurrentUser()

      const { data, error } = await client
        .from('projects')
        .select('*')
        .eq('id', projectId)
        .eq('owner_id', user.id) // Security: ownership check
        .single()

      if (error) {
        permanentLogger.captureError('PROJECTS_REPO', error, {
          operation: 'getProject',
          projectId,
          userId: user.id
        })
        throw error
      }

      // NO FALLBACK - throw if not found
      if (!data) {
        const notFoundError = new Error(`Project ${projectId} not found or unauthorized`)
        permanentLogger.captureError('PROJECTS_REPO', notFoundError, {
          projectId,
          userId: user.id
        })
        throw notFoundError
      }

      timer.stop()
      return data
    })
  }

  /**
   * Create new project - lets database generate UUID
   * CRITICAL: Never generate IDs in app code per CLAUDE.md
   */
  async createProject(project: Omit<ProjectInsert, 'id' | 'owner_id'>): Promise<Project> {
    const timer = permanentLogger.timing('repository.createProject')

    return this.execute('createProject', async (client) => {
      permanentLogger.breadcrumb('repository', 'Creating new project', {
        projectName: project.name,
        timestamp: Date.now()
      })

      const user = await this.getCurrentUser()

      // NO ID field - let PostgreSQL gen_random_uuid() handle it
      const { data, error } = await client
        .from('projects')
        .insert({
          ...project,
          owner_id: user.id
          // id is auto-generated by database
        })
        .select()
        .single()

      if (error) {
        permanentLogger.captureError('PROJECTS_REPO', error, {
          operation: 'createProject',
          projectName: project.name,
          userId: user.id
        })
        throw error
      }

      if (!data) {
        throw new Error('Project creation failed - no data returned')
      }

      const duration = timer.stop()
      permanentLogger.breadcrumb('repository', 'Project created', {
        projectId: data.id,
        duration
      })

      return data
    })
  }

  /**
   * Update project with ownership validation
   * Technical PM: Only project owner can update
   */
  async updateProject(projectId: string, updates: ProjectUpdate): Promise<Project> {
    const timer = permanentLogger.timing('repository.updateProject')

    return this.execute('updateProject', async (client) => {
      permanentLogger.breadcrumb('repository', 'Updating project', {
        projectId,
        timestamp: Date.now()
      })

      const user = await this.getCurrentUser()

      const { data, error } = await client
        .from('projects')
        .update(updates)
        .eq('id', projectId)
        .eq('owner_id', user.id) // Security: ownership check
        .select()
        .single()

      if (error) {
        permanentLogger.captureError('PROJECTS_REPO', error, {
          operation: 'updateProject',
          projectId,
          userId: user.id
        })
        throw error
      }

      if (!data) {
        throw new Error(`Project ${projectId} not found or unauthorized`)
      }

      timer.stop()
      return data
    })
  }

  /**
   * Get projects with aggregated counts
   * Technical PM: Single query with parallel count fetching for performance
   */
  async getUserProjectsWithCounts() {
    const timer = permanentLogger.timing('repository.getUserProjectsWithCounts')

    return this.execute('getUserProjectsWithCounts', async (client) => {
      permanentLogger.breadcrumb('repository', 'Fetching projects with counts', {
        timestamp: Date.now()
      })

      // Get base projects first
      const projects = await this.getUserProjects()

      // Parallel count fetching for efficiency
      const projectsWithCounts = await Promise.all(
        projects.map(async (project) => {
          const countTimer = permanentLogger.timing(`count.${project.id}`)

          try {
            const [artifactsResult, membersResult] = await Promise.all([
              client
                .from('artifacts')
                .select('id', { count: 'exact', head: true })
                .eq('project_id', project.id),
              client
                .from('project_members')
                .select('id', { count: 'exact', head: true })
                .eq('project_id', project.id)
            ])

            countTimer.stop()

            return {
              ...project,
              _count: {
                artifacts: artifactsResult.count || 0,
                project_members: membersResult.count || 0,
                risks: 0 // Table doesn't exist yet
              }
            }
          } catch (countError) {
            // Log but don't fail entire operation for count errors
            permanentLogger.captureError('PROJECTS_REPO', countError as Error, {
              operation: 'getProjectCounts',
              projectId: project.id
            })

            // Return project without counts rather than failing
            return {
              ...project,
              _count: {
                artifacts: 0,
                project_members: 0,
                risks: 0
              }
            }
          }
        })
      )

      const duration = timer.stop()
      permanentLogger.breadcrumb('repository', 'Projects with counts fetched', {
        projectCount: projectsWithCounts.length,
        duration
      })

      return projectsWithCounts
    })
  }

  /**
   * Delete project with cascade handling
   * Technical PM: Handles related data cleanup
   */
  async deleteProject(projectId: string): Promise<void> {
    const timer = permanentLogger.timing('repository.deleteProject')

    return this.execute('deleteProject', async (client) => {
      permanentLogger.breadcrumb('repository', 'Deleting project', {
        projectId,
        timestamp: Date.now()
      })

      const user = await this.getCurrentUser()

      // Delete with ownership check
      const { error } = await client
        .from('projects')
        .delete()
        .eq('id', projectId)
        .eq('owner_id', user.id)

      if (error) {
        permanentLogger.captureError('PROJECTS_REPO', error, {
          operation: 'deleteProject',
          projectId,
          userId: user.id
        })
        throw error
      }

      timer.stop()
      permanentLogger.breadcrumb('repository', 'Project deleted', {
        projectId
      })
    })
  }

  /**
   * Get all projects - Admin only
   * Technical PM: For admin statistics and project management
   */
  async getAllProjects(): Promise<Project[]> {
    const timer = permanentLogger.timing('repository.getAllProjects')

    return this.execute('getAllProjects', async (client) => {
      permanentLogger.breadcrumb('repository', 'Fetching all projects', {
        timestamp: Date.now()
      })

      const { data, error } = await client
        .from('projects')
        .select('*')
        .order('created_at', { ascending: false })

      if (error) {
        permanentLogger.captureError('PROJECTS_REPO', error, {
          operation: 'getAllProjects'
        })
        throw error
      }

      timer.stop()
      return data || []
    })
  }
}