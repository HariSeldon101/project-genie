/**
 * Data Quality Indicator System
 * 
 * This module provides types and utilities for tracking and displaying
 * the quality and source of data throughout the company intelligence system.
 * Every piece of data should be tagged with its source and confidence level.
 */

/**
 * Data source types indicating the origin and reliability of data
 */
export enum DataSource {
  /** ‚úÖ Real data from official sources (APIs, verified websites) */
  VERIFIED = 'verified',
  
  /** ‚ö†Ô∏è Calculated or estimated based on industry averages */
  ESTIMATED = 'estimated',
  
  /** üîÑ Fallback/default data when real data unavailable */
  FALLBACK = 'fallback',
  
  /** ü§ñ Generated by AI/LLM models */
  AI_GENERATED = 'ai',
  
  /** ‚ùì Source cannot be determined */
  UNKNOWN = 'unknown'
}

/**
 * Data quality metadata for tracking source and confidence
 */
export interface DataQualityMetadata {
  /** Primary data source */
  source: DataSource
  
  /** Confidence score 0-100 */
  confidence: number
  
  /** When the data was last updated */
  lastUpdated: Date
  
  /** Specific fields and their sources */
  fieldSources?: Record<string, DataSource>
  
  /** Additional context about the data source */
  sourceDetails?: string
  
  /** Whether data refresh is recommended */
  needsRefresh?: boolean
}

/**
 * Enhanced data wrapper that includes quality metadata
 */
export interface QualityTrackedData<T> {
  /** The actual data */
  data: T
  
  /** Quality metadata */
  quality: DataQualityMetadata
}

/**
 * Visual indicator configuration for UI display
 */
export interface DataQualityIndicator {
  /** Display text */
  label: string
  
  /** Icon/emoji to display */
  icon: string
  
  /** CSS class for styling */
  className: string
  
  /** Tooltip text explaining the data source */
  tooltip: string
  
  /** Color for visual display */
  color: string
  
  /** Background color for badges */
  backgroundColor: string
  
  /** Border color for emphasis */
  borderColor: string
}

/**
 * Data quality indicator configurations
 */
export const DATA_QUALITY_INDICATORS: Record<DataSource, DataQualityIndicator> = {
  [DataSource.VERIFIED]: {
    label: 'Verified',
    icon: '‚úÖ',
    className: 'data-badge-verified',
    tooltip: 'Verified data from official sources',
    color: '#2e7d32',
    backgroundColor: '#e8f5e9',
    borderColor: '#4caf50'
  },
  [DataSource.ESTIMATED]: {
    label: 'Estimated',
    icon: '‚ö†Ô∏è',
    className: 'data-badge-estimated',
    tooltip: 'Estimated based on industry averages',
    color: '#f57c00',
    backgroundColor: '#fff8e1',
    borderColor: '#ffc107'
  },
  [DataSource.FALLBACK]: {
    label: 'Fallback',
    icon: 'üîÑ',
    className: 'data-badge-fallback',
    tooltip: 'Fallback data - refresh recommended',
    color: '#e65100',
    backgroundColor: '#fff3e0',
    borderColor: '#ff9800'
  },
  [DataSource.AI_GENERATED]: {
    label: 'AI Generated',
    icon: 'ü§ñ',
    className: 'data-badge-ai',
    tooltip: 'AI-generated content',
    color: '#1565c0',
    backgroundColor: '#e3f2fd',
    borderColor: '#2196f3'
  },
  [DataSource.UNKNOWN]: {
    label: 'Unknown',
    icon: '‚ùì',
    className: 'data-badge-unknown',
    tooltip: 'Data source unknown',
    color: '#616161',
    backgroundColor: '#f5f5f5',
    borderColor: '#9e9e9e'
  }
}

/**
 * Calculate confidence score based on data source
 */
export function calculateConfidence(source: DataSource): number {
  const confidenceMap: Record<DataSource, number> = {
    [DataSource.VERIFIED]: 95,
    [DataSource.ESTIMATED]: 70,
    [DataSource.FALLBACK]: 30,
    [DataSource.AI_GENERATED]: 60,
    [DataSource.UNKNOWN]: 0
  }
  return confidenceMap[source] || 0
}

/**
 * Track data source and log appropriately
 */
export function trackDataSource<T>(
  data: T,
  source: DataSource,
  context: string,
  additionalInfo?: Record<string, any>
): QualityTrackedData<T> {
  const confidence = calculateConfidence(source)
  
  // Log data source tracking only on server side
  if (typeof window === 'undefined') {
    try {
      const { logger } = require('@/lib/utils/permanent-logger')
      const logLevel = source === DataSource.VERIFIED ? 'info' : 
                       source === DataSource.FALLBACK ? 'warn' : 'info'
      
      logger[logLevel]('DATA_QUALITY', `Data tracked: ${context}`, {
        source,
        confidence,
        context,
        ...additionalInfo
      })
    } catch (error) {
      // Log error but re-throw to avoid silent failures
      permanentLogger.captureError('ERROR', error as Error, {
        context: 'Unhandled error - needs proper handling'
      })
      throw error
    }
  }
  
  return {
    data,
    quality: {
      source,
      confidence,
      lastUpdated: new Date(),
      sourceDetails: context,
      needsRefresh: source === DataSource.FALLBACK || source === DataSource.UNKNOWN
    }
  }
}

/**
 * Generate HTML badge for data quality indicator
 */
export function generateDataQualityBadge(source: DataSource): string {
  const indicator = DATA_QUALITY_INDICATORS[source]
  return `<span class="${indicator.className}" title="${indicator.tooltip}">${indicator.icon} ${indicator.label}</span>`
}

/**
 * Generate inline indicator for table cells or small spaces
 */
export function generateInlineIndicator(source: DataSource): string {
  const indicator = DATA_QUALITY_INDICATORS[source]
  return `<span class="data-indicator" title="${indicator.tooltip}">${indicator.icon}</span>`
}

/**
 * Calculate overall data quality for a collection of fields
 */
export function calculateOverallQuality(fieldSources: Record<string, DataSource>): {
  overall: DataSource
  confidence: number
  breakdown: Record<DataSource, number>
} {
  const counts: Record<DataSource, number> = {
    [DataSource.VERIFIED]: 0,
    [DataSource.ESTIMATED]: 0,
    [DataSource.FALLBACK]: 0,
    [DataSource.AI_GENERATED]: 0,
    [DataSource.UNKNOWN]: 0
  }
  
  // Count occurrences of each source type
  Object.values(fieldSources).forEach(source => {
    counts[source] = (counts[source] || 0) + 1
  })
  
  const total = Object.values(counts).reduce((sum, count) => sum + count, 0)
  
  // Calculate percentages
  const breakdown: Record<DataSource, number> = {} as any
  Object.entries(counts).forEach(([source, count]) => {
    breakdown[source as DataSource] = total > 0 ? (count / total) * 100 : 0
  })
  
  // Determine overall quality (prioritize worst quality)
  let overall: DataSource = DataSource.VERIFIED
  if (counts[DataSource.UNKNOWN] > 0) overall = DataSource.UNKNOWN
  else if (counts[DataSource.FALLBACK] > total * 0.3) overall = DataSource.FALLBACK
  else if (counts[DataSource.ESTIMATED] > total * 0.5) overall = DataSource.ESTIMATED
  else if (counts[DataSource.AI_GENERATED] > total * 0.5) overall = DataSource.AI_GENERATED
  
  // Calculate weighted confidence
  const weightedConfidence = Object.entries(counts).reduce((sum, [source, count]) => {
    return sum + (calculateConfidence(source as DataSource) * count)
  }, 0) / (total || 1)
  
  return {
    overall,
    confidence: Math.round(weightedConfidence),
    breakdown
  }
}

/**
 * Generate a data quality summary component
 */
export function generateDataQualitySummary(breakdown: Record<DataSource, number>): string {
  const items = Object.entries(breakdown)
    .filter(([_, percentage]) => percentage > 0)
    .sort((a, b) => b[1] - a[1])
    .map(([source, percentage]) => {
      const indicator = DATA_QUALITY_INDICATORS[source as DataSource]
      return `
        <div class="quality-metric">
          <span class="icon">${indicator.icon}</span>
          <span class="label">${indicator.label}</span>
          <span class="value">${percentage.toFixed(0)}%</span>
        </div>
      `
    })
    .join('')
  
  return `
    <div class="data-quality-summary">
      <h4>Data Quality Overview</h4>
      <div class="quality-metrics">
        ${items}
      </div>
      <div class="quality-bar">
        ${Object.entries(breakdown)
          .filter(([_, percentage]) => percentage > 0)
          .map(([source, percentage]) => {
            const indicator = DATA_QUALITY_INDICATORS[source as DataSource]
            return `<div class="${indicator.className}" style="width: ${percentage}%; background-color: ${indicator.backgroundColor}"></div>`
          })
          .join('')}
      </div>
    </div>
  `
}

/**
 * CSS styles for data quality indicators
 */
export const DATA_QUALITY_STYLES = `
  /* Data quality badges */
  .data-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.85em;
    font-weight: 500;
    margin-left: 8px;
    border: 1px solid;
  }
  
  .data-badge-verified {
    background: #e8f5e9;
    color: #2e7d32;
    border-color: #4caf50;
  }
  
  .data-badge-estimated {
    background: #fff8e1;
    color: #f57c00;
    border-color: #ffc107;
  }
  
  .data-badge-fallback {
    background: #fff3e0;
    color: #e65100;
    border-color: #ff9800;
  }
  
  .data-badge-ai {
    background: #e3f2fd;
    color: #1565c0;
    border-color: #2196f3;
  }
  
  .data-badge-unknown {
    background: #f5f5f5;
    color: #616161;
    border-color: #9e9e9e;
  }
  
  /* Inline indicators for tables */
  .data-indicator {
    margin-left: 4px;
    font-size: 0.9em;
    cursor: help;
  }
  
  /* Table cell backgrounds */
  td.verified-data {
    background: linear-gradient(90deg, #e8f5e9 0%, transparent 10%);
  }
  
  td.estimated-data {
    background: linear-gradient(90deg, #fff8e1 0%, transparent 10%);
  }
  
  td.fallback-data {
    background: linear-gradient(90deg, #fff3e0 0%, transparent 10%);
  }
  
  /* Data quality summary */
  .data-quality-summary {
    padding: 16px;
    background: #f9f9f9;
    border-radius: 8px;
    margin-bottom: 24px;
  }
  
  .data-quality-summary h4 {
    margin: 0 0 12px 0;
    font-size: 0.95em;
    font-weight: 600;
    color: #333;
  }
  
  .quality-metrics {
    display: flex;
    gap: 24px;
    margin-bottom: 12px;
  }
  
  .quality-metric {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .quality-metric .icon {
    font-size: 1.1em;
  }
  
  .quality-metric .label {
    font-size: 0.85em;
    color: #666;
  }
  
  .quality-metric .value {
    font-weight: 600;
    color: #333;
  }
  
  .quality-bar {
    display: flex;
    height: 8px;
    border-radius: 4px;
    overflow: hidden;
    background: #e0e0e0;
  }
  
  .quality-bar > div {
    transition: width 0.3s ease;
  }
  
  /* Hover effects */
  .data-badge:hover {
    opacity: 0.9;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  
  /* Data refresh prompt */
  .data-quality-note {
    margin-top: 12px;
    padding: 8px 12px;
    background: #fff3e0;
    border-left: 3px solid #ff9800;
    font-size: 0.9em;
    color: #e65100;
  }
  
  .data-quality-note a {
    color: #1565c0;
    text-decoration: underline;
    cursor: pointer;
  }
  
  .data-quality-note a:hover {
    color: #0d47a1;
  }
`