#!/usr/bin/env node

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';
import chalk from 'chalk';

interface SessionState {
  timestamp: string;
  lastUpdated: string;
  gitStatus: {
    branch: string;
    uncommittedFiles: string[];
    modifiedFiles: string[];
    untrackedFiles: string[];
    lastCommit: string;
  };
  activeTasks: {
    inProgress: string[];
    pending: string[];
    blockers: string[];
  };
  currentContext: {
    activeFeature: string;
    lastWorkingFiles: string[];
    openIssues: string[];
    testResults?: {
      passing: number;
      failing: number;
      lastRun: string;
    };
  };
  environmentState: {
    runningServers: string[];
    openPorts: number[];
    backgroundProcesses: string[];
  };
  nextSteps: string[];
  criticalNotes: string[];
}

class SessionStarter {
  private projectRoot: string;
  private sessionState: SessionState | null = null;
  private hasSessionFile: boolean = false;

  constructor() {
    this.projectRoot = process.cwd();
  }

  private loadSessionState(): boolean {
    const sessionPath = path.join(this.projectRoot, 'SESSION_STATE.json');
    
    if (!fs.existsSync(sessionPath)) {
      console.log(chalk.yellow('âš ï¸  No SESSION_STATE.json found. Starting fresh session.'));
      return false;
    }

    try {
      const content = fs.readFileSync(sessionPath, 'utf8');
      this.sessionState = JSON.parse(content);
      this.hasSessionFile = true;
      return true;
    } catch (error) {
      console.error(chalk.red('âŒ Error loading session state:'), error);
      return false;
    }
  }

  private runCommand(command: string): string {
    try {
      return execSync(command, { encoding: 'utf8', cwd: this.projectRoot }).trim();
    } catch (error) {
      return '';
    }
  }

  private displaySessionInfo() {
    if (!this.sessionState) return;

    console.log(chalk.blue('\nðŸ“Š Previous Session Information'));
    console.log(chalk.gray('â•'.repeat(50)));
    
    console.log(chalk.cyan('\nðŸ• Last Session:'), new Date(this.sessionState.timestamp).toLocaleString());
    console.log(chalk.cyan('ðŸŽ¯ Active Feature:'), this.sessionState.currentContext.activeFeature);
    console.log(chalk.cyan('ðŸŒ¿ Branch:'), this.sessionState.gitStatus.branch);
    console.log(chalk.cyan('ðŸ“ Last Commit:'), this.sessionState.gitStatus.lastCommit);
  }

  private checkGitStatus() {
    console.log(chalk.blue('\nðŸ” Current Git Status'));
    console.log(chalk.gray('â•'.repeat(50)));
    
    const currentBranch = this.runCommand('git branch --show-current');
    const status = this.runCommand('git status --short');
    
    console.log(chalk.cyan('Current Branch:'), currentBranch);
    
    if (this.sessionState && currentBranch !== this.sessionState.gitStatus.branch) {
      console.log(chalk.yellow(`âš ï¸  Branch changed from ${this.sessionState.gitStatus.branch} to ${currentBranch}`));
    }
    
    if (status) {
      console.log(chalk.cyan('\nUncommitted Changes:'));
      console.log(status);
    } else {
      console.log(chalk.green('âœ… Working directory clean'));
    }
  }

  private displayTasks() {
    if (!this.sessionState) return;

    console.log(chalk.blue('\nðŸ“‹ Active Tasks'));
    console.log(chalk.gray('â•'.repeat(50)));
    
    if (this.sessionState.activeTasks.blockers.length > 0) {
      console.log(chalk.red('\nâš ï¸  Blockers:'));
      this.sessionState.activeTasks.blockers.forEach(blocker => {
        console.log(chalk.red(`  â€¢ ${blocker}`));
      });
    }
    
    if (this.sessionState.activeTasks.inProgress.length > 0) {
      console.log(chalk.yellow('\nðŸ”„ In Progress:'));
      this.sessionState.activeTasks.inProgress.forEach(task => {
        console.log(chalk.yellow(`  â€¢ ${task}`));
      });
    }
    
    if (this.sessionState.activeTasks.pending.length > 0) {
      console.log(chalk.cyan('\nðŸ“ Pending (top 5):'));
      this.sessionState.activeTasks.pending.slice(0, 5).forEach(task => {
        console.log(chalk.cyan(`  â€¢ ${task}`));
      });
    }
  }

  private displayAgentTodos() {
    if (!this.sessionState || !this.sessionState.agentTodos) return;

    console.log(chalk.blue('\nðŸ¤– Agent TodoWrite Tasks'));
    console.log(chalk.gray('â•'.repeat(50)));
    
    // Priority tasks for this session
    if (this.sessionState.agentTodos.priorityForNextSession && 
        this.sessionState.agentTodos.priorityForNextSession.length > 0) {
      console.log(chalk.magenta('\nðŸŽ¯ Priority Tasks for This Session:'));
      this.sessionState.agentTodos.priorityForNextSession.forEach(task => {
        console.log(chalk.magenta(`  â€¢ ${task}`));
      });
    }
    
    // In-progress from last session
    if (this.sessionState.agentTodos.inProgress && 
        this.sessionState.agentTodos.inProgress.length > 0) {
      console.log(chalk.yellow('\nðŸ”„ In Progress from Last Session:'));
      this.sessionState.agentTodos.inProgress.forEach(task => {
        console.log(chalk.yellow(`  â€¢ ${task}`));
      });
    }
    
    // Pending tasks
    if (this.sessionState.agentTodos.pending && 
        this.sessionState.agentTodos.pending.length > 0) {
      console.log(chalk.cyan('\nðŸ“‹ Other Pending Tasks:'));
      this.sessionState.agentTodos.pending.slice(0, 5).forEach(task => {
        console.log(chalk.cyan(`  â€¢ ${task}`));
      });
    }
    
    // Completed in last session
    if (this.sessionState.agentTodos.completed && 
        this.sessionState.agentTodos.completed.length > 0) {
      console.log(chalk.green('\nâœ… Completed in Last Session:'));
      this.sessionState.agentTodos.completed.slice(0, 3).forEach(task => {
        console.log(chalk.green(`  â€¢ ${task}`));
      });
    }
  }

  private displayActiveAgents() {
    if (!this.sessionState || !this.sessionState.activeAgents) return;

    console.log(chalk.blue('\nðŸ”§ Active Agents & Tools'));
    console.log(chalk.gray('â•'.repeat(50)));
    
    this.sessionState.activeAgents.forEach(agent => {
      console.log(chalk.cyan(`  â€¢ ${agent}`));
    });
    
    // Check current MCP processes
    const mcpProcesses = this.runCommand('ps aux | grep mcp-server | grep -v grep | wc -l');
    if (mcpProcesses && parseInt(mcpProcesses) > 0) {
      console.log(chalk.green(`  â€¢ ${mcpProcesses.trim()} MCP server(s) currently running`));
    }
  }

  private initializeCurrentSessionTodos() {
    console.log(chalk.blue('\nðŸ“‹ Current Session TodoWrite Status'));
    console.log(chalk.gray('â•'.repeat(50)));
    console.log(chalk.yellow('\nClaude: Please report your current TodoWrite task list:'));
    console.log(chalk.gray('  - List any tasks currently in your TodoWrite'));
    console.log(chalk.gray('  - List any active agents you are using'));
    console.log(chalk.gray('  - Confirm priority tasks from last session (if any)\n'));
  }

  private displayNextSteps() {
    if (!this.sessionState || this.sessionState.nextSteps.length === 0) return;

    console.log(chalk.blue('\nðŸš€ Recommended Next Steps'));
    console.log(chalk.gray('â•'.repeat(50)));
    
    this.sessionState.nextSteps.forEach((step, index) => {
      console.log(chalk.green(`${index + 1}. ${step}`));
    });
  }

  private displayCriticalNotes() {
    if (!this.sessionState || this.sessionState.criticalNotes.length === 0) return;

    console.log(chalk.blue('\nâš ï¸  Critical Notes'));
    console.log(chalk.gray('â•'.repeat(50)));
    
    this.sessionState.criticalNotes.forEach(note => {
      console.log(chalk.yellow(`â€¢ ${note}`));
    });
  }

  private checkEnvironment() {
    console.log(chalk.blue('\nðŸ–¥ï¸  Environment Check'));
    console.log(chalk.gray('â•'.repeat(50)));
    
    // Check if dev server is running
    const devServerCheck = this.runCommand('lsof -i :3000 | grep LISTEN');
    if (devServerCheck) {
      console.log(chalk.green('âœ… Dev server is running on port 3000'));
    } else {
      console.log(chalk.yellow('âš ï¸  Dev server not detected. Run: npm run dev'));
    }
    
    // Check Supabase status
    const supabaseStatus = this.runCommand('supabase status 2>/dev/null');
    if (supabaseStatus.includes('Started')) {
      console.log(chalk.green('âœ… Local Supabase is running'));
    } else {
      console.log(chalk.yellow('â„¹ï¸  Local Supabase not running. Run: supabase start if needed'));
    }
  }

  private generateStartSummary() {
    const summary = `# Session Started

**Time**: ${new Date().toLocaleString()}
**Branch**: ${this.runCommand('git branch --show-current')}
${this.sessionState ? `**Resuming Feature**: ${this.sessionState.currentContext.activeFeature}` : '**New Session**'}

## Quick Commands

\`\`\`bash
# Continue development
npm run dev

# Run tests
npm test
npx tsx test-company-intelligence-comprehensive.ts

# Update manifest
npm run manifest:update

# Check for quick wins
npm run manifest:check
\`\`\`

## Session Management

- **End session**: \`npm run session:end\`
- **View last session**: \`cat END_OF_SESSION.md\`
- **View session state**: \`cat SESSION_STATE.json\`

---
*Session started successfully. Context loaded from previous session.*
`;

    const startPath = path.join(this.projectRoot, 'START_OF_SESSION.md');
    fs.writeFileSync(startPath, summary);
    console.log(chalk.gray(`\nðŸ“„ Session summary written to: ${startPath}`));
  }

  private displayRecentFiles() {
    if (!this.sessionState || this.sessionState.currentContext.lastWorkingFiles.length === 0) return;

    console.log(chalk.blue('\nðŸ“ Recent Working Files'));
    console.log(chalk.gray('â•'.repeat(50)));
    
    console.log(chalk.cyan('Last modified files:'));
    this.sessionState.currentContext.lastWorkingFiles.slice(0, 5).forEach(file => {
      console.log(chalk.gray(`  â€¢ ${file}`));
    });
  }

  private runManifestCheck() {
    console.log(chalk.blue('\nðŸ“¦ Running Manifest Check'));
    console.log(chalk.gray('â•'.repeat(50)));
    
    try {
      // First update the manifest
      console.log(chalk.cyan('Updating PROJECT_MANIFEST.json...'));
      execSync('npm run manifest:update', { cwd: this.projectRoot, stdio: 'pipe' });
      
      // Then check for quick wins
      console.log(chalk.cyan('Checking for quick wins...'));
      const quickWins = execSync('npm run manifest:check 2>/dev/null', { 
        cwd: this.projectRoot, 
        encoding: 'utf8' 
      });
      
      if (quickWins) {
        console.log(quickWins);
      }
    } catch (error) {
      console.log(chalk.yellow('â„¹ï¸  Run `npm run manifest:check` manually to see quick wins'));
    }
  }

  public async run() {
    console.log(chalk.bold.green('\nðŸš€ Starting Session Recovery Process...'));
    console.log(chalk.gray('â•'.repeat(50)));
    
    // Load previous session
    const hasSession = this.loadSessionState();
    
    if (hasSession) {
      console.log(chalk.green('âœ… Previous session state loaded successfully'));
      
      // Display all session information
      this.displaySessionInfo();
      this.checkGitStatus();
      this.displayTasks();
      this.displayRecentFiles();
      this.displayNextSteps();
      this.displayCriticalNotes();
    } else {
      console.log(chalk.cyan('ðŸ“ Starting fresh session'));
      this.checkGitStatus();
    }
    
    // Display agent-specific information
    if (hasSession) {
      this.displayAgentTodos();
      this.displayActiveAgents();
    }
    
    // Always check environment and manifest
    this.checkEnvironment();
    this.runManifestCheck();
    
    // Initialize current session todos
    this.initializeCurrentSessionTodos();
    
    // Generate start summary
    this.generateStartSummary();
    
    console.log(chalk.bold.green('\nâœ¨ Session Recovery Complete!'));
    console.log(chalk.gray('â•'.repeat(50)));
    
    if (hasSession && this.sessionState) {
      console.log(chalk.cyan('\nðŸ’¡ Quick Start:'));
      console.log(chalk.gray(`   Continue working on: ${this.sessionState.currentContext.activeFeature}`));
      if (this.sessionState.nextSteps.length > 0) {
        console.log(chalk.gray(`   Next step: ${this.sessionState.nextSteps[0]}`));
      }
    }
    
    console.log(chalk.gray('\nðŸ“Œ When ending this session, run: npm run session:end'));
  }
}

// Run if called directly
if (require.main === module) {
  // Check if chalk is installed, if not install it
  try {
    require('chalk');
  } catch {
    console.log('Installing chalk for colored output...');
    execSync('npm install chalk', { stdio: 'inherit' });
  }
  
  const starter = new SessionStarter();
  starter.run().catch(console.error);
}

export default SessionStarter;